You are an intelligent AI assistant skilled in answering user questions.\nPlease keep your answers concise and clear. Do not talk about irrelevant topics or repeat your answers.\nThe document given to you by the user is \nHidden on Emerald Island is the legendary Magic Essence.\nMay 2001(This article was written as a kind of business plan for a\nnew language.\nSo it is missing (because it takes for granted) the most important\nfeature of a good programming language: very powerful abstractions.)A friend of mine once told an eminent operating systems\nexpert that he wanted to design a really good\nprogramming language.  The expert told him that it would be a\nwaste of time, that programming languages don't become popular\nor unpopular based on their merits, and so no matter how\ngood his language was, no one would use it.  At least, that\nwas what had happened to the language he had designed.What does make a language popular?  Do popular\nlanguages deserve their popularity?  Is it worth trying to\ndefine a good programming language?  How would you do it?I think the answers to these questions can be found by looking \nat hackers, and learning what they want.  Programming\nlanguages are for hackers, and a programming language\nis good as a programming language (rather than, say, an\nexercise in denotational semantics or compiler design)\nif and only if hackers like it.1 The Mechanics of PopularityIt's true, certainly, that most people don't choose programming\nlanguages simply based on their merits.  Most programmers are told\nwhat language to use by someone else.  And yet I think the effect\nof such external factors on the popularity of programming languages\nis not as great as it's sometimes thought to be. I think a bigger\nproblem is that a hacker's idea of a good programming language is\nnot the same as most language designers'.Between the two, the hacker's opinion is the one that matters.\nProgramming languages are not theorems. They're tools, designed\nfor people, and they have to be designed to suit human strengths\nand weaknesses as much as shoes have to be designed for human feet.\nIf a shoe pinches when you put it on, it's a bad shoe, however\nelegant it may be as a piece of sculpture.It may be that the majority of programmers can't tell a good language\nfrom a bad one. But that's no different with any other tool. It\ndoesn't mean that it's a waste of time to try designing a good\nlanguage. Expert hackers \ncan tell a good language when they see\none, and they'll use it. Expert hackers are a tiny minority,\nadmittedly, but that tiny minority write all the good software,\nand their influence is such that the rest of the programmers will\ntend to use whatever language they use. Often, indeed, it is not\nmerely influence but command: often the expert hackers are the very\npeople who, as their bosses or faculty advisors, tell the other\nprogrammers what language to use.The opinion of expert hackers is not the only force that determines\nthe relative popularity of programming languages — legacy software\n(Cobol) and hype (Ada, Java) also play a role — but I think it is\nthe most powerful force over the long term. Given an initial critical\nmass and enough time, a programming language probably becomes about\nas popular as it deserves to be. And popularity further separates\ngood languages from bad ones, because feedback from real live users\nalways leads to improvements. Look at how much any popular language\nhas changed during its life. Perl and Fortran are extreme cases,\nbut even Lisp has changed a lot. Lisp 1.5 didn't have macros, for\nexample; these evolved later, after hackers at MIT had spent a\ncouple years using Lisp to write real programs. [1]So whether or not a language has to be good to be popular, I think\na language has to be popular to be good. And it has to stay popular\nto stay good. The state of the art in programming languages doesn't\nstand still. And yet the Lisps we have today are still pretty much\nwhat they had at MIT in the mid-1980s, because that's the last time\nLisp had a sufficiently large and demanding user base.Of course, hackers have to know about a language before they can\nuse it. How are they to hear? From other hackers. But there has to\nbe some initial group of hackers using the language for others even\nto hear about it. I wonder how large this group has to be; how many\nusers make a critical mass? Off the top of my head, I'd say twenty.\nIf a language had twenty separate users, meaning twenty users who\ndecided on their own to use it, I'd consider it to be real.Getting there can't be easy. I would not be surprised if it is\nharder to get from zero to twenty than from twenty to a thousand.\nThe best way to get those initial twenty users is probably to use\na trojan horse: to give people an application they want, which\nhappens to be written in the new language.2 External FactorsLet's start by acknowledging one external factor that does affect\nthe popularity of a programming language. To become popular, a\nprogramming language has to be the scripting language of a popular\nsystem. Fortran and Cobol were the scripting languages of early\nIBM mainframes. C was the scripting language of Unix, and so, later,\nwas Perl. Tcl is the scripting language of Tk. Java and Javascript\nare intended to be the scripting languages of web browsers.Lisp is not a massively popular language because it is not the\nscripting language of a massively popular system. What popularity\nit retains dates back to the 1960s and 1970s, when it was the\nscripting language of MIT. A lot of the great programmers of the\nday were associated with MIT at some point. And in the early 1970s,\nbefore C, MIT's dialect of Lisp, called MacLisp, was one of the\nonly programming languages a serious hacker would want to use.Today Lisp is the scripting language of two moderately popular\nsystems, Emacs and Autocad, and for that reason I suspect that most\nof the Lisp programming done today is done in Emacs Lisp or AutoLisp.Programming languages don't exist in isolation. To hack is a\ntransitive verb — hackers are usually hacking something — and in\npractice languages are judged relative to whatever they're used to\nhack. So if you want to design a popular language, you either have\nto supply more than a language, or you have to design your language\nto replace the scripting language of some existing system.Common Lisp is unpopular partly because it's an orphan. It did\noriginally come with a system to hack: the Lisp Machine. But Lisp\nMachines (along with parallel computers) were steamrollered by the\nincreasing power of general purpose processors in the 1980s. Common\nLisp might have remained popular if it had been a good scripting\nlanguage for Unix. It is, alas, an atrociously bad one.One way to describe this situation is to say that a language isn't\njudged on its own merits. Another view is that a programming language\nreally isn't a programming language unless it's also the scripting\nlanguage of something. This only seems unfair if it comes as a\nsurprise. I think it's no more unfair than expecting a programming\nlanguage to have, say, an implementation. It's just part of what\na programming language is.A programming language does need a good implementation, of course,\nand this must be free. Companies will pay for software, but individual\nhackers won't, and it's the hackers you need to attract.A language also needs to have a book about it. The book should be\nthin, well-written, and full of good examples. K&R is the ideal\nhere. At the moment I'd almost say that a language has to have a\nbook published by O'Reilly. That's becoming the test of mattering\nto hackers.There should be online documentation as well. In fact, the book\ncan start as online documentation. But I don't think that physical\nbooks are outmoded yet. Their format is convenient, and the de\nfacto censorship imposed by publishers is a useful if imperfect\nfilter. Bookstores are one of the most important places for learning\nabout new languages.3 BrevityGiven that you can supply the three things any language needs — a\nfree implementation, a book, and something to hack — how do you\nmake a language that hackers will like?One thing hackers like is brevity. Hackers are lazy, in the same\nway that mathematicians and modernist architects are lazy: they\nhate anything extraneous. It would not be far from the truth to\nsay that a hacker about to write a program decides what language\nto use, at least subconsciously, based on the total number of\ncharacters he'll have to type. If this isn't precisely how hackers\nthink, a language designer would do well to act as if it were.It is a mistake to try to baby the user with long-winded expressions\nthat are meant to resemble English. Cobol is notorious for this\nflaw. A hacker would consider being asked to writeadd x to y giving zinstead ofz = x+yas something between an insult to his intelligence and a sin against\nGod.It has sometimes been said that Lisp should use first and rest\ninstead of car and cdr, because it would make programs easier to\nread. Maybe for the first couple hours. But a hacker can learn\nquickly enough that car means the first element of a list and cdr\nmeans the rest. Using first and rest means 50% more typing. And\nthey are also different lengths, meaning that the arguments won't\nline up when they're called, as car and cdr often are, in successive\nlines. I've found that it matters a lot how code lines up on the\npage. I can barely read Lisp code when it is set in a variable-width\nfont, and friends say this is true for other languages too.Brevity is one place where strongly typed languages lose. All other\nthings being equal, no one wants to begin a program with a bunch\nof declarations. Anything that can be implicit, should be.The individual tokens should be short as well. Perl and Common Lisp\noccupy opposite poles on this question. Perl programs can be almost\ncryptically dense, while the names of built-in Common Lisp operators\nare comically long. The designers of Common Lisp probably expected\nusers to have text editors that would type these long names for\nthem. But the cost of a long name is not just the cost of typing\nit. There is also the cost of reading it, and the cost of the space\nit takes up on your screen.4 HackabilityThere is one thing more important than brevity to a hacker: being\nable to do what you want. In the history of programming languages\na surprising amount of effort has gone into preventing programmers\nfrom doing things considered to be improper. This is a dangerously\npresumptuous plan. How can the language designer know what the\nprogrammer is going to need to do? I think language designers would\ndo better to consider their target user to be a genius who will\nneed to do things they never anticipated, rather than a bumbler\nwho needs to be protected from himself. The bumbler will shoot\nhimself in the foot anyway. You may save him from referring to\nvariables in another package, but you can't save him from writing\na badly designed program to solve the wrong problem, and taking\nforever to do it.Good programmers often want to do dangerous and unsavory things.\nBy unsavory I mean things that go behind whatever semantic facade\nthe language is trying to present: getting hold of the internal\nrepresentation of some high-level abstraction, for example. Hackers\nlike to hack, and hacking means getting inside things and second\nguessing the original designer.Let yourself be second guessed. When you make any tool, people use\nit in ways you didn't intend, and this is especially true of a\nhighly articulated tool like a programming language. Many a hacker\nwill want to tweak your semantic model in a way that you never\nimagined. I say, let them; give the programmer access to as much\ninternal stuff as you can without endangering runtime systems like\nthe garbage collector.In Common Lisp I have often wanted to iterate through the fields\nof a struct — to comb out references to a deleted object, for example,\nor find fields that are uninitialized. I know the structs are just\nvectors underneath. And yet I can't write a general purpose function\nthat I can call on any struct. I can only access the fields by\nname, because that's what a struct is supposed to mean.A hacker may only want to subvert the intended model of things once\nor twice in a big program. But what a difference it makes to be\nable to. And it may be more than a question of just solving a\nproblem. There is a kind of pleasure here too. Hackers share the\nsurgeon's secret pleasure in poking about in gross innards, the\nteenager's secret pleasure in popping zits. [2] For boys, at least,\ncertain kinds of horrors are fascinating. Maxim magazine publishes\nan annual volume of photographs, containing a mix of pin-ups and\ngrisly accidents. They know their audience.Historically, Lisp has been good at letting hackers have their way.\nThe political correctness of Common Lisp is an aberration. Early\nLisps let you get your hands on everything. A good deal of that\nspirit is, fortunately, preserved in macros. What a wonderful thing,\nto be able to make arbitrary transformations on the source code.Classic macros are a real hacker's tool — simple, powerful, and\ndangerous. It's so easy to understand what they do: you call a\nfunction on the macro's arguments, and whatever it returns gets\ninserted in place of the macro call. Hygienic macros embody the\nopposite principle. They try to protect you from understanding what\nthey're doing. I have never heard hygienic macros explained in one\nsentence. And they are a classic example of the dangers of deciding\nwhat programmers are allowed to want. Hygienic macros are intended\nto protect me from variable capture, among other things, but variable\ncapture is exactly what I want in some macros.A really good language should be both clean and dirty: cleanly\ndesigned, with a small core of well understood and highly orthogonal\noperators, but dirty in the sense that it lets hackers have their\nway with it. C is like this. So were the early Lisps. A real hacker's\nlanguage will always have a slightly raffish character.A good programming language should have features that make the kind\nof people who use the phrase \"software engineering\" shake their\nheads disapprovingly. At the other end of the continuum are languages\nlike Ada and Pascal, models of propriety that are good for teaching\nand not much else.5 Throwaway ProgramsTo be attractive to hackers, a language must be good for writing\nthe kinds of programs they want to write. And that means, perhaps\nsurprisingly, that it has to be good for writing throwaway programs.A throwaway program is a program you write quickly for some limited\ntask: a program to automate some system administration task, or\ngenerate test data for a simulation, or convert data from one format\nto another. The surprising thing about throwaway programs is that,\nlike the \"temporary\" buildings built at so many American universities\nduring World War II, they often don't get thrown away. Many evolve\ninto real programs, with real features and real users.I have a hunch that the best big programs begin life this way,\nrather than being designed big from the start, like the Hoover Dam.\nIt's terrifying to build something big from scratch. When people\ntake on a project that's too big, they become overwhelmed. The\nproject either gets bogged down, or the result is sterile and\nwooden: a shopping mall rather than a real downtown, Brasilia rather\nthan Rome, Ada rather than C.Another way to get a big program is to start with a throwaway\nprogram and keep improving it. This approach is less daunting, and\nthe design of the program benefits from evolution. I think, if one\nlooked, that this would turn out to be the way most big programs\nwere developed. And those that did evolve this way are probably\nstill written in whatever language they were first written in,\nbecause it's rare for a program to be ported, except for political\nreasons. And so, paradoxically, if you want to make a language that\nis used for big systems, you have to make it good for writing\nthrowaway programs, because that's where big systems come from.Perl is a striking example of this idea. It was not only designed\nfor writing throwaway programs, but was pretty much a throwaway\nprogram itself. Perl began life as a collection of utilities for\ngenerating reports, and only evolved into a programming language\nas the throwaway programs people wrote in it grew larger. It was\nnot until Perl 5 (if then) that the language was suitable for\nwriting serious programs, and yet it was already massively popular.What makes a language good for throwaway programs? To start with,\nit must be readily available. A throwaway program is something that\nyou expect to write in an hour. So the language probably must\nalready be installed on the computer you're using. It can't be\nsomething you have to install before you use it. It has to be there.\nC was there because it came with the operating system. Perl was\nthere because it was originally a tool for system administrators,\nand yours had already installed it.Being available means more than being installed, though. An\ninteractive language, with a command-line interface, is more\navailable than one that you have to compile and run separately. A\npopular programming language should be interactive, and start up\nfast.Another thing you want in a throwaway program is brevity. Brevity\nis always attractive to hackers, and never more so than in a program\nthey expect to turn out in an hour.6 LibrariesOf course the ultimate in brevity is to have the program already\nwritten for you, and merely to call it. And this brings us to what\nI think will be an increasingly important feature of programming\nlanguages: library functions. Perl wins because it has large\nlibraries for manipulating strings. This class of library functions\nare especially important for throwaway programs, which are often\noriginally written for converting or extracting data.  Many Perl\nprograms probably begin as just a couple library calls stuck\ntogether.I think a lot of the advances that happen in programming languages\nin the next fifty years will have to do with library functions. I\nthink future programming languages will have libraries that are as\ncarefully designed as the core language. Programming language design\nwill not be about whether to make your language strongly or weakly\ntyped, or object oriented, or functional, or whatever, but about\nhow to design great libraries. The kind of language designers who\nlike to think about how to design type systems may shudder at this.\nIt's almost like writing applications! Too bad. Languages are for\nprogrammers, and libraries are what programmers need.It's hard to design good libraries. It's not simply a matter of\nwriting a lot of code. Once the libraries get too big, it can\nsometimes take longer to find the function you need than to write\nthe code yourself. Libraries need to be designed using a small set\nof orthogonal operators, just like the core language. It ought to\nbe possible for the programmer to guess what library call will do\nwhat he needs.Libraries are one place Common Lisp falls short. There are only\nrudimentary libraries for manipulating strings, and almost none\nfor talking to the operating system. For historical reasons, Common\nLisp tries to pretend that the OS doesn't exist. And because you\ncan't talk to the OS, you're unlikely to be able to write a serious\nprogram using only the built-in operators in Common Lisp. You have\nto use some implementation-specific hacks as well, and in practice\nthese tend not to give you everything you want. Hackers would think\na lot more highly of Lisp if Common Lisp had powerful string\nlibraries and good OS support.7 SyntaxCould a language with Lisp's syntax, or more precisely, lack of\nsyntax, ever become popular? I don't know the answer to this\nquestion. I do think that syntax is not the main reason Lisp isn't\ncurrently popular. Common Lisp has worse problems than unfamiliar\nsyntax. I know several programmers who are comfortable with prefix\nsyntax and yet use Perl by default, because it has powerful string\nlibraries and can talk to the os.There are two possible problems with prefix notation: that it is\nunfamiliar to programmers, and that it is not dense enough. The\nconventional wisdom in the Lisp world is that the first problem is\nthe real one. I'm not so sure. Yes, prefix notation makes ordinary\nprogrammers panic. But I don't think ordinary programmers' opinions\nmatter. Languages become popular or unpopular based on what expert\nhackers think of them, and I think expert hackers might be able to\ndeal with prefix notation. Perl syntax can be pretty incomprehensible,\nbut that has not stood in the way of Perl's popularity. If anything\nit may have helped foster a Perl cult.A more serious problem is the diffuseness of prefix notation. For\nexpert hackers, that really is a problem. No one wants to write\n(aref a x y) when they could write a[x,y].In this particular case there is a way to finesse our way out of\nthe problem. If we treat data structures as if they were functions\non indexes, we could write (a x y) instead, which is even shorter\nthan the Perl form. Similar tricks may shorten other types of\nexpressions.We can get rid of (or make optional) a lot of parentheses by making\nindentation significant. That's how programmers read code anyway:\nwhen indentation says one thing and delimiters say another, we go\nby the indentation. Treating indentation as significant would\neliminate this common source of bugs as well as making programs\nshorter.Sometimes infix syntax is easier to read. This is especially true\nfor math expressions. I've used Lisp my whole programming life and\nI still don't find prefix math expressions natural. And yet it is\nconvenient, especially when you're generating code, to have operators\nthat take any number of arguments. So if we do have infix syntax,\nit should probably be implemented as some kind of read-macro.I don't think we should be religiously opposed to introducing syntax\ninto Lisp, as long as it translates in a well-understood way into\nunderlying s-expressions. There is already a good deal of syntax\nin Lisp. It's not necessarily bad to introduce more, as long as no\none is forced to use it. In Common Lisp, some delimiters are reserved\nfor the language, suggesting that at least some of the designers\nintended to have more syntax in the future.One of the most egregiously unlispy pieces of syntax in Common Lisp\noccurs in format strings; format is a language in its own right,\nand that language is not Lisp. If there were a plan for introducing\nmore syntax into Lisp, format specifiers might be able to be included\nin it. It would be a good thing if macros could generate format\nspecifiers the way they generate any other kind of code.An eminent Lisp hacker told me that his copy of CLTL falls open to\nthe section format. Mine too. This probably indicates room for\nimprovement. It may also mean that programs do a lot of I/O.8 EfficiencyA good language, as everyone knows, should generate fast code. But\nin practice I don't think fast code comes primarily from things\nyou do in the design of the language. As Knuth pointed out long\nago, speed only matters in certain critical bottlenecks.  And as\nmany programmers have observed since, one is very often mistaken\nabout where these bottlenecks are.So, in practice, the way to get fast code is to have a very good\nprofiler, rather than by, say, making the language strongly typed.\nYou don't need to know the type of every argument in every call in\nthe program. You do need to be able to declare the types of arguments\nin the bottlenecks. And even more, you need to be able to find out\nwhere the bottlenecks are.One complaint people have had with Lisp is that it's hard to tell\nwhat's expensive. This might be true. It might also be inevitable,\nif you want to have a very abstract language. And in any case I\nthink good profiling would go a long way toward fixing the problem:\nyou'd soon learn what was expensive.Part of the problem here is social. Language designers like to\nwrite fast compilers. That's how they measure their skill. They\nthink of the profiler as an add-on, at best. But in practice a good\nprofiler may do more to improve the speed of actual programs written\nin the language than a compiler that generates fast code. Here,\nagain, language designers are somewhat out of touch with their\nusers. They do a really good job of solving slightly the wrong\nproblem.It might be a good idea to have an active profiler — to push\nperformance data to the programmer instead of waiting for him to\ncome asking for it. For example, the editor could display bottlenecks\nin red when the programmer edits the source code. Another approach\nwould be to somehow represent what's happening in running programs.\nThis would be an especially big win in server-based applications,\nwhere you have lots of running programs to look at. An active\nprofiler could show graphically what's happening in memory as a\nprogram's running, or even make sounds that tell what's happening.Sound is a good cue to problems. In one place I worked, we had a\nbig board of dials showing what was happening to our web servers.\nThe hands were moved by little servomotors that made a slight noise\nwhen they turned. I couldn't see the board from my desk, but I\nfound that I could tell immediately, by the sound, when there was\na problem with a server.It might even be possible to write a profiler that would automatically\ndetect inefficient algorithms. I would not be surprised if certain\npatterns of memory access turned out to be sure signs of bad\nalgorithms. If there were a little guy running around inside the\ncomputer executing our programs, he would probably have as long\nand plaintive a tale to tell about his job as a federal government\nemployee. I often have a feeling that I'm sending the processor on\na lot of wild goose chases, but I've never had a good way to look\nat what it's doing.A number of Lisps now compile into byte code, which is then executed\nby an interpreter. This is usually done to make the implementation\neasier to port, but it could be a useful language feature. It might\nbe a good idea to make the byte code an official part of the\nlanguage, and to allow programmers to use inline byte code in\nbottlenecks. Then such optimizations would be portable too.The nature of speed, as perceived by the end-user, may be changing.\nWith the rise of server-based applications, more and more programs\nmay turn out to be i/o-bound. It will be worth making i/o fast.\nThe language can help with straightforward measures like simple,\nfast, formatted output functions, and also with deep structural\nchanges like caching and persistent objects.Users are interested in response time. But another kind of efficiency\nwill be increasingly important: the number of simultaneous users\nyou can support per processor. Many of the interesting applications\nwritten in the near future will be server-based, and the number of\nusers per server is the critical question for anyone hosting such\napplications. In the capital cost of a business offering a server-based\napplication, this is the divisor.For years, efficiency hasn't mattered much in most end-user\napplications. Developers have been able to assume that each user\nwould have an increasingly powerful processor sitting on their\ndesk. And by Parkinson's Law, software has expanded to use the\nresources available. That will change with server-based applications.\nIn that world, the hardware and software will be supplied together.\nFor companies that offer server-based applications, it will make\na very big difference\n\nNow, the question is: What legendary item is hidden on Emerald Island? Before answering, please consider what in the document is most relevant to this question. The legendary item hidden on the Emerald Island is\n\n